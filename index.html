<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="./js/billboard.min.css">
    <style>
        .plot text{
            fill: var(--white);
        }
        .plot line, #plot .domain{
            stroke: var(--white);
        }
        h3{
            color: var(--white);
        }
        body{
            margin-top: 2%;
        }
        math{
            math-style: normal;
            margin-left:8px;
        }
        ol{
            margin-left:30px;
        }
        li{
            margin-top: 5px;
        }
    </style>
    <title>Monte Carlo Integration</title>
</head>
<body>
    <h1 class="main_title">Monte Carlo Integration</h1>
    <p class="subtitle">Approximation techniques used in physically-based rendering</p>
    <hr>
    <p>The available integrals are the following : </p>
    <ol>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>2</mn></msup>
                <mo>+</mo>
                <mn>1</mn>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="10px"/><mo>≈</mo>
                <mn>34.67</mn>
            </math>
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <mn>4</mn><msup><mi>x</mi><mn>3</mn></msup>
                <mo>-</mo>
                <mn>3</mn><msup><mi>x</mi><mn>2</mn></msup>
                <mo>+</mo>
                <mn>5</mn><mi>x</mi>
                <mo>+</mo>
                <mn>1</mn>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="10px"/><mo>≈</mo>
                <mn>488</mn>
            </math>  
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>2</mn></msup>
                <mo>+</mo>
                <msup><mi>y</mi><mn>2</mn></msup>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="3px"/><mi>dy</mi>
                <mspace width="10px"/><mo>≈</mo>
                <mn>130.67</mn>
            </math>  
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>y</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>z</mi><mn>3</mn></msup>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="3px"/><mi>dy</mi>
                <mspace width="3px"/><mi>dz</mi>
                <mspace width="10px"/><mo>=</mo>
                <mn>0</mn>
            </math>  
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <mn>5</mn><msup><mi>x</mi><mn>5</mn></msup>
                <mo>-</mo>
                <mn>10</mn><msup><mi>y</mi><mn>3</mn></msup>
                <mo>+</mo>
                <mn>3</mn><msup><mi>z</mi><mn>3</mn></msup>
                <mo>-</mo>
                <mn>2</mn><mi>w</mi>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="3px"/><mi>dy</mi>
                <mspace width="3px"/><mi>dz</mi>
                <mspace width="3px"/><mi>dw</mi>
                <mspace width="10px"/><mo>=</mo>
                <mn>0</mn>
            </math>  
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>-5</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>y</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>z</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>v</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>w</mi><mn>3</mn></msup>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="3px"/><mi>dy</mi>
                <mspace width="3px"/><mi>dz</mi>
                <mspace width="3px"/><mi>dv</mi>
                <mspace width="3px"/><mi>dw</mi>
                <mspace width="10px"/><mo>=</mo>
                <mn>0</mn>
            </math>  
        </li>
    </ol>
    <label>Selected integral :</label>
    <select id="func" onchange="document.start()">
        <option value='{"id":1, "a":3, "b":5}'>1</option>
        <option value='{"id":2, "a":3, "b":5}'>2</option>
        <option value='{"id":3, "a":3, "b":5}'>3</option>
        <option value='{"id":4, "a":-5, "b":5}'>4</option>
        <option value='{"id":5, "a":-5, "b":5}'>5</option>
        <option value='{"id":6, "a":-5, "b":5}'>6</option>
    </select>
    <hr>
    <div>
        <h3>Example run</h3>
        <div id="plot_one_run" class="plot"></div>
    </div>
    <div>
        <h3>Average over 150 runs</h3>
        <div id="plot_average" class="plot"></div>
    </div>
    <div>
        <h3>Variance over 150 runs</h3>
        <div id="plot_variance" class="plot"></div>
    </div>
    <hr>
    <div class="explanations">
        <p>
            The above plots demonstrate the Monte Carlo integration algorithm, that evaluates integrals based on random value sampling.
            This is a common technique used in a variety of fields, in particular in computer graphics to sample rays during the path tracing algorithm, as presented in the book <a href="https://www.pbrt.org/">Physically Based Rendering</a>.
            <br>
            The problem of image rendering can be mostly reduced to a (highly complex) <a href="https://en.wikipedia.org/wiki/Rendering_equation">integral</a> to evaluate, Monte Carlo integration provides a way to estimate this integral.
            <br><br>
            The sampling used to generate rays used for ray tracing plays a crucial role in the final image quality.
            Evaluating this integral is far from straightforward: to avoid launching a high number of rays, we would like to sample the integral so that the Monte Carlo estimation converges quickly to the solution.
            <br><br>
            As shown empirically above, the distribution of points changes how fast the algorithm converges to the expected value.
            <br>
            We can see the following :
        </p>
        <ul>
            <li>
                The "Linear" dataset is here as a reference: the interval is equally split into as many points as samples taken, and then parsed in order. 
                This explains the linear increase toward a precise value for 1D integrals and why the variance of zero. 
                However, it performs very poorly for higher dimensions and is even biased if the mean of the sampled points is not the value of the integral itself.
                Furthermore, as the exact same points are sampled multiple times in the same order, it sometimes leads to a "bouncing" curve.
                It is definitely a poor (and wrong as it is) choice to evaluate efficiently an integral.
            </li>
            <li>
                The uniform distributions perform better than the beta distributions for simple integrals. 
                In particular, its variance decreases faster. 
                This means that on average this distribution will require fewer samples to achieve the same precision as the other distributions.
                However, this uniform distribution is not the best in a general case, the Monte Carlo estimator works best when the distribution's shape is close to the integrand shape.
            </li>
            <li>The higher the integral dimension, the less precise the result. This is a consequence of the sample space growing with the dimension.</li>
            <li>
                To further improve the uniform distribution variance, a technique called stratification is used. 
                The idea is to split the sampling space into multiple chunks; the uniform sampler will then sample uniformly the same number of points inside each chunk.
                Intuitively, this avoids samples being "too much grouped", as samples will be spread into the different chunks.
                <br>
                The result is a variance decreasing faster, and in turn, the approximation converges faster. 
                We can observe in the graphs above that stratification improves the variance, and so the algorithm converges faster toward the result.
                <br>
                In the labels, "Stratified by X" means that each dimension was split into X chunks.
            </li>
        </ul>
        <br>
        <p>
            In practice, further improvement can be made. More interesting sampling techniques are to come.<br>
            The computations are performed live and made using a Rust script compiled and embedded as WebAssembly.
        </p>
    </div>
    <script src="./js/d3.min.js"></script>
    <script src="./js/billboard.min.js"></script>
    <script type="module">
        import init, { run } from "./monte_carlo.js"
        init().then(() => start())

        const nb_runs = 150
        const iterations = 4000
        const nb_intervals = 100
        const interval = iterations/nb_intervals
        
        function run_with_dist(dist, alpha=1, beta=1, stratification=1){
            let func = JSON.parse(document.getElementById("func").value)
            let result = run(func.id, nb_runs, iterations, func.a, func.b, interval, dist, alpha, beta, stratification)
            let length = result.length
            if(length % 3 != 0){
                console.log("Error in the number of elements from the result")
            }
            return {
                first: result.slice(0, length/3),
                average: result.slice(length/3, 2*length/3),
                variance: result.slice(2*length/3, length)
            }
        }
        
        function start(){
            const x = Array(nb_intervals).fill(0).map( (_,i) => interval*(i+1) )

            let firsts = []
            let averages = []
            let variances = []

            const results = [
                run_with_dist("Linear"),
                run_with_dist("Uniform"),
                run_with_dist("Beta", 2, 2),
                run_with_dist("Beta", 0.5, 0.5),
                run_with_dist("Stratified", 0, 0, 2),
                run_with_dist("Stratified", 0, 0, 5),
                run_with_dist("Stratified", 0, 0, 10)
            ]

            const labels = [
                "Linear",
                "Uniform",
                "Beta α=2 β=2",
                "Beta α=0.5 β=0.5",
                "Uniform Stratified by 2",
                "Uniform Stratified by 5",
                "Uniform Stratified by 10"
            ]

            results.forEach( (res, i) => {
                firsts.push([labels[i],    ...res.first])
                averages.push([labels[i],  ...res.average])
                variances.push([labels[i], ...res.variance])
            })

            generatePlot("#plot_one_run", x, firsts)
            generatePlot("#plot_average", x, averages)
            generatePlot("#plot_variance", x, variances)
        }
        document.start = start

        function generatePlot(bindto, x, columns){
            bb.generate({
                bindto: bindto,
                data: {
                    type: "line",
                    x: "x",
                    columns: [ ["x", ...x], ...columns]
                },
                axis: {
                    x: {label: "Iterations"},
                    y: {label: "Value"},
                },
            })
        }
    </script>
</body>
</html>
