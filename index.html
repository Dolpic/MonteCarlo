<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="./js/billboard.min.css">
    <style>
        .plot text{
            fill: var(--white);
        }
        .plot line, #plot .domain{
            stroke: var(--white);
        }
        h3{
            color: var(--white);
        }
        body{
            margin-top: 2%;
        }
        math{
            math-style: normal;
            margin-left:8px;
        }
        ol{
            margin-left:30px;
        }
        li{
            margin-top: 5px;
        }
    </style>
    <title>Monte Carlo Integration</title>
</head>
<body>
    <h1 class="main_title">Monte Carlo Integration</h1>
    <p class="subtitle">Approximation techniques used in physically-based rendering</p>
    <hr>
    <p>For now, all the integrals are evaluated between 3 and 5, the available integrals are the following : </p>
    <ol>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>2</mn></msup>
                <mo>+</mo>
                <mn>1</mn>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="10px"/><mo>≈</mo>
                <mn>34.67</mn>
            </math>
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <mn>4</mn><msup><mi>x</mi><mn>3</mn></msup>
                <mo>-</mo>
                <mn>3</mn><msup><mi>x</mi><mn>2</mn></msup>
                <mo>+</mo>
                <mn>5</mn><mi>x</mi>
                <mo>+</mo>
                <mn>1</mn>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="10px"/><mo>≈</mo>
                <mn>488</mn>
            </math>  
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>2</mn></msup>
                <mo>+</mo>
                <msup><mi>y</mi><mn>2</mn></msup>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="3px"/><mi>dy</mi>
                <mspace width="10px"/><mo>≈</mo>
                <mn>130.67</mn>
            </math>  
        </li>
        <li>
            <math display="inline-block">
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msubsup><mo>∫</mo><mn>3</mn><mn>5</mn></msubsup>
                <msup><mi>x</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>y</mi><mn>3</mn></msup>
                <mo>+</mo>
                <msup><mi>z</mi><mn>3</mn></msup>
                <mspace width="3px"/><mi>dx</mi>
                <mspace width="3px"/><mi>dy</mi>
                <mspace width="3px"/><mi>dz</mi>
                <mspace width="10px"/><mo>=</mo>
                <mn>1632</mn>
            </math>  
        </li>
    </ol>
    <label>Selected integral :</label>
    <select id="func" onchange="document.start()">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
    </select>
    <hr>
    <div>
        <h3>Example run</h3>
        <div id="plot_one_run" class="plot"></div>
    </div>
    <div>
        <h3>Average over 50 runs</h3>
        <div id="plot_average" class="plot"></div>
    </div>
    <div>
        <h3>Variance over 50 runs</h3>
        <div id="plot_variance" class="plot"></div>
    </div>
    <hr>
    <div class="explanations">
        <p>
            The above plots demonstrate the Monte Carlo integration algorithm, that evaluates integrals based on random value sampling.
            This is a common technique used in a variety of fields, in particular in computer graphics to sample rays during the path tracing algorithm, as presented in the book <a href="https://www.pbrt.org/">Physically Based Rendering</a>.
            <br>
            The problem of image rendering can be mostly reduced to a (highly complex) <a href="https://en.wikipedia.org/wiki/Rendering_equation">integral</a> to evaluate, Monte Carlo integration provides a way to estimate this integral.
            <br><br>
            The sampling used to generate rays used for ray tracing plays a crucial role in the final image quality.
            Evaluating this integral is far from straightforward: to avoid launching a high number of rays, we would like to sample the integral so that the Monte Carlo estimation converges quickly to the solution.
            <br><br>
            As shown empirically above, the distribution of points changes how fast the algorithm converges to the expected value.
            <br>
            We can notice the following :
        </p>
        <ul>
            <li>
                The "Linear" dataset is here as a reference: the interval is equally split into as many points as samples taken. 
                This explains the linear increase toward a precise value for 1D integrals and the variance of zero. 
                However, it performs very poorly for higher dimensions and is even biased if the mean of the sampled points is not the value of the integral itself.
            </li>
            <li>The higher the integral dimension, the less precise the result. This is a consequence of the sample space growing with the dimension.</li>
            <li>
                The uniform distribution performs better than other distributions. 
                In particular, its variance decreases faster. 
                This means that on average this distribution will require fewer samples to achieve the same precision as the other distributions.
                However, this uniform distribution is not the best in a general case, the Monte Carlo estimator works best when the distribution's shape is close to the integrand distribution.
            </li>
        </ul>
        <br>
        <p>
            In practice, all these samplers do not perform very well. More interesting sampling techniques are to come.<br>
            The computations are made using a Rust script compiled and embedded as WebAssembly.
        </p>
    </div>
    <script src="./js/d3.min.js"></script>
    <script src="./js/billboard.min.js"></script>
    <script type="module">
        import init, { run } from "./monte_carlo.js"
        init().then(() => start())

        const nb_runs = 50
        const iterations = 4000
        const nb_intervals = 80
        const interval = iterations/nb_intervals
        
        function run_with_dist(dist, alpha=1, beta=1, a=3, b=5){
            let func = parseInt(document.getElementById("func").value)
            let result = run(func, nb_runs, iterations, a, b, interval, dist, alpha, beta)
            let length = result.length
            if(length % 3 != 0){
                console.log("Error in the number of elements from the result")
            }
            return {
                first: result.slice(0, length/3),
                average: result.slice(length/3, 2*length/3),
                variance: result.slice(2*length/3, length)
            }
        }
        
        function start(){
            const x = Array(nb_intervals).fill(0).map( (_,i) => interval*(i+1) )

            let firsts = []
            let averages = []
            let variances = []

            const results = [
                run_with_dist("Linear"),
                run_with_dist("Uniform"),
                run_with_dist("Beta", 2, 2),
                run_with_dist("Beta", 0.5, 0.5),
                run_with_dist("Beta", 0.1, 0.1),
            ]

            const labels = [
                "Linear",
                "Uniform",
                "Beta α=2 β=2",
                "Beta α=0.5 β=0.5",
                "Beta α=0.1 β=0.1",
            ]

            results.forEach( (res, i) => {
                firsts.push([labels[i],    ...res.first])
                averages.push([labels[i],  ...res.average])
                variances.push([labels[i], ...res.variance])
            })

            generatePlot("#plot_one_run", x, firsts)
            generatePlot("#plot_average", x, averages)
            generatePlot("#plot_variance", x, variances)
        }
        document.start = start

        function generatePlot(bindto, x, columns){
            bb.generate({
                bindto: bindto,
                data: {
                    type: "line",
                    x: "x",
                    columns: [ ["x", ...x], ...columns]
                },
                axis: {
                    x: {label: "Iterations"},
                    y: {label: "Value"},
                },
            })
        }
    </script>
</body>
</html>
